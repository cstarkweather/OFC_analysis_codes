
%%
n = 4; %subject 4 for this example plotting shown in Figure 5a-b
num_bootstraps = 500;
for i=1:size(sliding_epochs,1)
    error_real(i) = std(all_subjects_accuracies{n,i})/sqrt(500);
    error_shuffled(i) = std(all_subjects_shuffled_accuracies{n,i})/sqrt(500);
    plot(sliding_epochs(i,1),all_subjects_mean_accuracies(n,i),'.','Markersize',20,'Color',[0 0 0])
    hold on
    plot(sliding_epochs(i,1),all_subjects_mean_shuffled_accuracies(n,i),'.','Markersize',20,'Color',[0.5 0.5 0.5])
    hold on
end
figure
errorbar(sliding_epochs(:,1)',all_subjects_mean_accuracies(n,:),error_real,'Color',[0 0 0],'CapSize', 0)
hold on
errorbar(sliding_epochs(:,1)',all_subjects_mean_shuffled_accuracies(n,:),error_shuffled,'Color',[0.5 0.5 0.5],'CapSize', 0)
hold on

yline(sum(subject(n).decision==1)/(sum(subject(n).decision==1) + sum(subject(n).decision==0)),'r--')

set(gca, 'TickDir', 'out', 'Box', 'off', 'Color', 'w');
set(gcf, 'Color', 'w');
xlim([4250 4700])
exportgraphics(gcf, '/results/figure5a.png');
disp('Saved /results/figure5a.png');

%% example single trials - posterior probabilities over time
n=4;
loadname = strcat(['posteriors_' num2str(n) '.mat']);
load(loadname)

loadname = strcat(['state_metadata_' num2str(n) '.mat']);
load(loadname)

loadname = strcat(['chosen_indices_' num2str(n) '.mat']);
load(loadname)


spacing = 5;start_sliding = 1;length_trial_epoch = 10;
last_sliding = 5001 - length_trial_epoch;num_epochs1 = (last_sliding - start_sliding)/spacing + 1;
trial_epochs= zeros(num_epochs1,2);
trial_epochs(1,:) = [start_sliding (start_sliding +length_trial_epoch-1)];
for i=2:num_epochs1
    trial_epochs(i,:) = [(trial_epochs(i-1,1)+spacing) (trial_epochs(i-1,2)+ spacing) ];
end

    %calculate the combined confidence interval
    % Assume posterior_probabilities_shuffled is a cell array where each cell contains a matrix
    num_shuffles = length(posterior_probabilities_shuffled);

    % Initialize an empty array to store all data points
    all_data = [];

    % Loop through each shuffled posterior probabilities matrix
    for i = 1:num_shuffles
        data = posterior_probabilities_shuffled{i};
        % Flatten the matrix to a vector and concatenate with all_data
        all_data = [all_data; data(:)];
    end

    % Compute the 95% confidence interval for all combined data points
    combined_conf_interval{n} = prctile(all_data, [2.5 97.5]);

which_trial = 106;


filter = find(subject(n).decision<2);
defined_bins = ~isnan(posterior_probabilities(which_trial,:));

figure
% Plot the posterior probability for approach
plot(trial_epochs(defined_bins)-5000, posterior_probabilities(which_trial, defined_bins), 'LineWidth', 2, 'DisplayName', 'Approach Probability');
hold on;

% Plot the posterior probability for avoid (1 - approach)
plot(trial_epochs(defined_bins)-5000, 1 - posterior_probabilities(which_trial, defined_bins), 'LineWidth', 2, 'DisplayName', 'Avoid Probability');
hold on;

% Plot confidence interval lines
yline(combined_conf_interval{n}(1), 'LineWidth', 2);
hold on;
yline(combined_conf_interval{n}(2), 'LineWidth', 2);

% Label the plot and adjust formatting
ylim([0 1]);
xlabel('Time from cue (ms)', 'FontSize', 12);
ylabel('Posterior Probability (Approach)', 'FontSize', 12);
%legend({'Approach Probability', 'Avoid Probability'}, 'FontSize', 12);
set(gca, 'TickDir', 'out', 'Box', 'off', 'Color', 'w');
set(gcf, 'Color', 'w');
title(['Trial: ' num2str(which_trial) ', Decision: ' num2str(subject(n).decision(filter(which_trial)))], 'FontSize', 14);
%decision = 1 is approach; 0 is avoidance

hold on
xline(entry_times(trial_identity==filter(which_trial) & state_identity>0),'r')
xline(departure_times(trial_identity==filter(which_trial)  & state_identity>0),'r--')
xline(entry_times(trial_identity==filter(which_trial) & state_identity<0),'b')
xline(departure_times(trial_identity==filter(which_trial)  & state_identity<0),'b--')
set(gca, 'TickDir', 'out', 'Box', 'off', 'Color', 'w');
set(gcf, 'Color', 'w');
exportgraphics(gcf, '/results/figure5b.png');
disp('Saved /results/figure5b.png');


%% Noisy ramp vs discrete attractor?
pos_coding_e=[];
neg_coding_e=[];
pos_coding_n=[];
neg_coding_n=[];
for n = 1:6
    posteriors_name = strcat(['/data/posteriors_' num2str(n) '.mat']);
    load(posteriors_name,'glm_model')
    electrodes_name = strcat(['/data/chosen_indices_' num2str(n) '.mat']);
    load(electrodes_name)
    electrode_indices = electrode_indices';
    beta_weights = glm_model.Coefficients{2:end, 1};
    pos_coding_e = [pos_coding_e;electrode_indices(beta_weights>0)];
    neg_coding_e = [neg_coding_e;electrode_indices(beta_weights<0)];
    pos_coding_n = [pos_coding_n;ones(sum(beta_weights>0),1)*n];
    neg_coding_n = [neg_coding_n;ones(sum(beta_weights<0),1)*n];
end

colorflag = 0;
signal_bounds = [-300 300];
baseline_bounds = [4800 5000];
window = signal_bounds(2) - signal_bounds(1) + 1;
duration_threshold = 100;

smoothing_kernel = 1;ID = 1;

x2 = round(signal_bounds(1):smoothing_kernel:signal_bounds(2));

figure;
hold on;

n_set = pos_coding_n;
e_set = pos_coding_e;

for_psth = zeros(length(e_set),signal_bounds(2) - signal_bounds(1)+1);


for j = 1:6

    for a = 1:length(e_set)
        e = e_set(a);
        n = n_set(a);
        state_name = strcat(['/data/state_metadata_' num2str(n) '.mat']);
        load(state_name)
        bound1 = -rt*0.33;
        bound2 = -rt*0.67;
        trialset = [...
             {find(state_identity==-1 & entry_times>bound1)},...
             {find(state_identity==-1 & entry_times<bound1 & entry_times>bound2)},...
             {find(state_identity==-1 & entry_times<bound2)},...
             {find(state_identity==1 & entry_times<bound2)},...
             {find(state_identity==1 & entry_times<bound1 & entry_times>bound2)},...
             {find(state_identity==1 & entry_times>bound1)},
             ];


        indices = trialset{j};
        temp=[];
        for i=1:length(indices)
            if (entry_times(indices(i))+5000>abs(signal_bounds(1)))
                baseline = [subject(n).electrode(e).trigger(1).high_gamma_mat(trial_identity(indices(i)), baseline_bounds(1):baseline_bounds(2))];
                avg_baseline = sum(baseline, 2) / size(baseline, 2);
                temp = [temp;(subject(n).electrode(e).trigger(2).high_gamma_mat(trial_identity(indices(i)), (5000+entry_times(indices(i))+signal_bounds(1)):(5000+entry_times(indices(i))+signal_bounds(2))) - avg_baseline) ./ avg_baseline];
            else
            end
        end

        for_psth(a,:)=sum(temp)/size(temp,1);

    end
    y = smooth(sum(for_psth) / size(for_psth, 1), smoothing_kernel);
    dy = zeros(length(y),1);
    for c = 1:length(x2) - 1
        dy((c - 1) * smoothing_kernel + 1:c * smoothing_kernel) = std(sum(for_psth(:, (c - 1) * smoothing_kernel + 1:c * smoothing_kernel),2)/smoothing_kernel)/sqrt(size(for_psth,1));
    end

    smooth_y = y(1:smoothing_kernel:end+1-smoothing_kernel)';
    smoothed_dy = smooth(dy,smoothing_kernel);
    if colorflag ==0
        fill([(signal_bounds(1):signal_bounds(2)), fliplr((signal_bounds(1):signal_bounds(2)))], [(y - smoothed_dy)'  fliplr((y + smoothed_dy)')],[1 - (j - 1) / (length(trialset) - 0.9), (j - 1) / (length(trialset) - 0.9), 0.15], 'linestyle', 'none','FaceAlpha', 0.6);
        hold on
        plot((signal_bounds(1):signal_bounds(2))', y, 'Linewidth',2,'Color',[0.7*(1 - (j - 1) / (length(trialset) - 1)) 0.5*(j - 1) / (length(trialset) - 1)  0 1])
        hold on
    else

        fill([(signal_bounds(1):signal_bounds(2)), fliplr((signal_bounds(1):signal_bounds(2)))], [(y - smoothed_dy)'  fliplr((y + smoothed_dy)')], [1 - (j-1) / (length(trialset)-1), (j -1)/ (length(trialset)-1), 1], 'linestyle', 'none','FaceAlpha', 0.6);
        hold on
        plot((signal_bounds(1):signal_bounds(2))', y, 'k','Linewidth',2)
        hold on
    end

        for_anova{j} = for_psth;
end


% Adjust plot appearance
set(gca, 'TickDir', 'out');
box off;
set(gcf, 'Color', 'w');
xlabel('Time from state switch (milliseconds)', 'FontSize', 14);
ylabel('High gamma amplitude', 'FontSize', 14);
xline(0)
xlim([-20 120])
exportgraphics(gcf, '/results/figure5c.png');
disp('Saved /results/figure5c.png');


%% anova FOR POSITIVE STATE SWITCHES
fprintf('ANOVA comparing tertiles of switches to approach state')
anova2([sum(for_anova{4}(:,300:375),2),sum(for_anova{5}(:,300:375),2),sum(for_anova{6}(:,300:375),2)])

%% proportion of posterior probability outside of the 95% CI over all subjects
num_subjects = 6;
proportion_outside0 = zeros(1,num_subjects);
for n = 1:num_subjects
    load(strcat(['/data/posteriors_' num2str(n) '.mat']))
    % Assume posterior_probabilities_shuffled is a cell array where each cell contains a matrix
    num_shuffles = length(posterior_probabilities_shuffled);

    % Initialize an empty array to store all data points
    all_data = [];

    % Loop through each shuffled posterior probabilities matrix
    for i = 1:num_shuffles
        data = posterior_probabilities_shuffled{i};
        % Flatten the matrix to a vector and concatenate with all_data
        all_data = [all_data; data(:)];
    end

    % Compute the 95% confidence interval for all combined data points
    combined_conf_interval = prctile(all_data, [2.5 97.5]);

    % Flatten the matrix to a vector
    temp = posterior_probabilities(~isnan(posterior_probabilities));
    posterior_probabilities_vector = temp(:);

    % Count the number of elements outside the confidence interval
    num_outside = sum(posterior_probabilities_vector < combined_conf_interval(1) | posterior_probabilities_vector > combined_conf_interval(2));

    % Calculate the total number of elements
    total_elements = numel(posterior_probabilities_vector);

    % Calculate the proportion of elements outside the confidence interval
    proportion_outside0(n) = num_outside / total_elements;
end
fprintf('the proportion of true posteriors outside the 95 percent CI is:')
mean(proportion_outside0)
fprintf('with a standard deviation of:')
std(proportion_outside0)



%% confirm proportion outside not just due to decoding window
proportion_outside = zeros(1,num_subjects);
for n = 1:6
    load(strcat(['/data/posteriors_' num2str(n) '.mat']))
    % Assume posterior_probabilities_shuffled is a cell array where each cell contains a matrix
    num_shuffles = length(posterior_probabilities_shuffled);

    % Initialize an empty array to store all data points
    all_data = [];

    % Loop through each shuffled posterior probabilities matrix
    for i = 1:num_shuffles
        data = posterior_probabilities_shuffled{i};
        % Flatten the matrix to a vector and concatenate with all_data
        all_data = [all_data; data(:)];
    end

    % Compute the 95% confidence interval for all combined data points
    combined_conf_interval = prctile(all_data, [2.5 97.5]);

    % proportion of values outside CI

    % Flatten the matrix to a vector
    % determine optimal decoding window
    best_epoch = sliding_epochs(find(all_subjects_mean_accuracies(n,:) == max(all_subjects_mean_accuracies(n,:))),1);

    temp1 = posterior_probabilities(:,1:round(best_epoch/5));
    posterior_probabilities_vector = temp1(~isnan(temp1));

    % Count the number of elements outside the confidence interval
    num_outside = sum(posterior_probabilities_vector < combined_conf_interval(1) | posterior_probabilities_vector > combined_conf_interval(2));

    % Calculate the total number of elements
    total_elements = numel(posterior_probabilities_vector);

    % Calculate the proportion of elements outside the confidence interval
    proportion_outside(n) = num_outside / total_elements;
end

fprintf('excluding the decoding window, the proportion of true posteriors outside the 95 percent CI is:')
mean(proportion_outside)
fprintf('with a standard deviation of:')
std(proportion_outside)

%% conflict versus number of states visited
figure
num_subjects = 6;
num_states = zeros(num_subjects, 2);
conflict_all = []; 
total_states_all = []; 
subject_ids = [];

% Create a color gradient from black to light grey for each subject.
colors = zeros(num_subjects, 3);
for n = 1:num_subjects
    c = (n-1) * (0.8/(num_subjects-1));  % subject 1 is [0,0,0] and subject 6 is [0.8,0.8,0.8]
    colors(n,:) = [c, c, c];
end

% Set the jitter magnitude (adjust as needed)
jitterMagnitude = 0.01;

for n = 1:num_subjects
    clear trialset;
    unique_trial_types = unique(subject(n).trial_type_trial);
    for i = 1:length(unique_trial_types)
        trialset{i} = find(subject(n).trial_type_trial == unique_trial_types(i) & subject(n).decision < 2);
    end

    state_metadata_name = strcat(['/data/state_metadata_' num2str(n) '.mat']);
    load(state_metadata_name)

    for a = 1:length(trialset)
        filter = trialset{a};
        total_states = 0;
        for i = 1:length(filter)
            entry_times_trial = entry_times(trial_identity == filter(i));
            total_states = total_states + length(entry_times_trial);
        end
        % Average the number of states across trials for this trial type
        num_states(n,a) = total_states / length(filter);
    end

    % Use the original conflict values and add jitter for visualization.
    x_original = subject(n).conflict_trial_type;
    x_jittered = x_original + jitterMagnitude * randn(size(x_original));
    
    % Scatter plot with 40% opacity
    scatter(x_jittered, num_states(n, unique_trial_types), 36, colors(n,:), ...
        'filled', 'MarkerFaceAlpha', 0.4)
    hold on
    
    subject_ids = [subject_ids, ones(1, length(unique_trial_types)) * n];
    conflict_all = [conflict_all, x_original];
    total_states_all = [total_states_all, num_states(n, unique_trial_types)];
    
    % Compute the best-fit line using the original (non-jittered) conflict values.
    p_coeff = polyfit(x_original, num_states(n, unique_trial_types), 1);
    x_fit = linspace(min(x_original), max(x_original), 100);
    y_fit = polyval(p_coeff, x_fit);
    
    % Plot the best-fit line using the same subject-specific color.
    plot(x_fit, y_fit, '-', 'LineWidth', 2, 'Color', colors(n,:));
end

xlabel('Conflict')
ylabel('Number of States Visited')
title('Conflict versus number of states visited per trial')
exportgraphics(gcf, '/results/figure5d.png');
disp('Saved /results/figure5d.png');


%% stats- linear mixed effects model - does conflict modulate number of states visited?

tbl = table(subject_ids', conflict_all', total_states_all',...
    'VariableNames', {'Subject', 'Conflict', 'TotalStates'});

tbl.Subject = categorical(tbl.Subject);

% Define a mixed-effects model:
% The fixed effect is 'Conflict', and we include a random intercept for each subject.
lme = fitlme(tbl, 'TotalStates ~ Conflict + Subject');

% View the model results:
disp(lme)

%% conflict versus state transition rate
figure

num_subjects = 6;
transition_rate = zeros(num_subjects, size(trialset,2));
conflict_all = []; transition_rate_all = []; subject_ids = [];

% Create a color gradient from black to light grey for each subject.
colors = zeros(num_subjects, 3);
for n = 1:num_subjects
    % Linear interpolation: subject 1 is black ([0,0,0]), subject 6 is light grey ([0.8,0.8,0.8])
    c = (n-1) * (0.8/(num_subjects-1));
    colors(n,:) = [c, c, c];
end

% Set the jitter magnitude (adjust as needed)
jitterMagnitude = 0.01;

for n = 1:num_subjects
    clear trialset;
    unique_trial_types = unique(subject(n).trial_type_trial);
    for i = 1:length(unique_trial_types)
        trialset{i} = find(subject(n).trial_type_trial == unique_trial_types(i) & subject(n).decision < 2);
    end

    state_metadata_name = strcat(['/data/state_metadata_' num2str(n) '.mat']);
    load(state_metadata_name)

    for a = 1:length(trialset)
        filter = trialset{a};
        total_transitions = 0;
        total_time = 0;
        for i = 1:length(filter)
            transition_times_trial = transitionentry_times_store(transition_trial_identity == filter(i));
            transition_type_trial = transition_types(transition_trial_identity == filter(i));
            total_transitions = total_transitions + sum(transition_type_trial > -3);
            total_time = total_time + subject(n).rt(filter(i));
        end
        transition_rate(n, a) = total_transitions / total_time * 1000;
    end

    % Use the original x-values (conflict) and add jitter
    x_original = subject(n).conflict_trial_type;
    x_jittered = x_original + jitterMagnitude * randn(size(x_original));
    
    % Use scatter to plot the jittered points with 40% opacity.
    scatter(x_jittered, transition_rate(n, unique_trial_types), 36, colors(n,:), 'filled', 'MarkerFaceAlpha', 0.4)
    hold on
    [h_ind(n), p_ind(n)] = corr(x_original', transition_rate(n, unique_trial_types)');
    
    subject_ids = [subject_ids, ones(1, length(unique_trial_types)) * n];
    conflict_all = [conflict_all, x_original];
    transition_rate_all = [transition_rate_all, transition_rate(n, unique_trial_types)];
    
    % Compute the best-fit line using the original (non-jittered) data.
    p_coeff = polyfit(x_original, transition_rate(n, unique_trial_types), 1);
    x_fit = linspace(min(x_original), max(x_original), 100);
    y_fit = polyval(p_coeff, x_fit);
    
    % Plot the best-fit line with the same subject-specific color.
    plot(x_fit, y_fit, '-', 'LineWidth', 2, 'Color', colors(n,:));
end

xlabel('Conflict')
ylabel('Transition Rate')
title('Conflict versus state transition rate')
exportgraphics(gcf, '/results/figure5e.png');
disp('Saved /results/figure5e.png');

%% stats- linear mixed effects model -   does conflict modulate transition rate?
% Suppose you have a table with the following columns:
% 'Subject', 'Conflict', and 'TransitionRate'
tbl = table(subject_ids', conflict_all', transition_rate_all',...
    'VariableNames', {'Subject', 'Conflict', 'TransitionRate'});

tbl.Subject = categorical(tbl.Subject);

% Define a mixed-effects model:
% The fixed effect is 'Conflict', and we include a random intercept for each subject.
lme = fitlme(tbl, 'TransitionRate ~ Conflict + Subject');

% View the model results:
disp(lme)
